
import { GoogleGenAI } from "@google/genai";
import { ArtStyle, AspectRatio, Character, Placement } from "../types";
import { getGeminiApiKey } from "../config/gemini";

// Helper to remove data URL prefix
const stripBase64Header = (dataUrl: string) => {
  return dataUrl.split(',')[1];
};

export const generateBackground = async (prompt: string, aspectRatio: AspectRatio, count: number = 1): Promise<string[]> => {
  const apiKey = getGeminiApiKey();
  const ai = new GoogleGenAI({ apiKey });
  
  const promises = Array.from({ length: count }).map(() => 
    ai.models.generateContent({
      model: 'gemini-3-pro-image-preview',
      contents: {
        parts: [{ text: `Generate a high quality background image. Description: ${prompt}. Aspect Ratio: ${aspectRatio}.` }]
      },
      config: {
        imageConfig: {
          aspectRatio: aspectRatio,
          imageSize: "1K"
        }
      }
    })
  );

  const responses = await Promise.all(promises);

  const images: string[] = [];

  for (const response of responses) {
    if (response.candidates && response.candidates[0].content.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData && part.inlineData.data) {
          images.push(`data:${part.inlineData.mimeType};base64,${part.inlineData.data}`);
          break;
        }
      }
    }
  }

  if (images.length === 0) {
    throw new Error("No images were generated by the model.");
  }

  return images;
};

export const generateComposite = async (
  characters: Character[],
  cleanBackground: string,
  layoutGuide: string,
  placements: Placement[],
  count: number = 1,
  refinement: string = ""
): Promise<string[]> => {
  const apiKey = getGeminiApiKey();
  const ai = new GoogleGenAI({ apiKey });

  // Construct placement instructions
  let placementInstructions = "";
  placements.forEach((p, index) => {
    const charIndex = characters.findIndex(c => c.id === p.characterId);
    const character = characters[charIndex];

    placementInstructions += `
    PLACEMENT ${index + 1}:
    - Reference Character: Use image "Character ${charIndex + 1}".
    - Target Location: Look at "Layout Guide" image. Find box colored ${p.color}.
    - Action/Pose: ${p.action}.
    - Render Style: ${character.style}.
    `;
  });

  const prompt = `
    You are an advanced image editing engine designed for PRECISE COMPOSITING.
    
    INPUTS:
    1. "Clean Background": THE MASTER REFERENCE. This image represents the scene that must be preserved.
    2. "Layout Guide": A reference image showing colored boxes where characters must be placed.
    ${characters.map((_, i) => `${i + 3}. "Character ${i + 1}": Reference image for character ${i + 1}.`).join('\n')}

    TASK:
    Insert the provided characters into the "Clean Background" at the locations specified by the "Layout Guide".
    
    CRITICAL CONSTRAINT - BACKGROUND INTEGRITY:
    - The "Clean Background" is IMMUTABLE. Do NOT change the background style, furniture, decorations, lighting, or layout.
    - Do NOT remove objects (tables, chairs, plants) from the background.
    - Do NOT hallucinate new background elements.
    - ONLY modify the pixels within the character bounding boxes and their immediate shadows.
    - The final image must look exactly like the "Clean Background" with the characters added on top.

    CRITICAL CONSTRAINT - CHARACTER STYLING:
    - Apply the requested art style ONLY to the character itself.
    - Do not bleed the character's art style into the surrounding background.
    
    CRITICAL CONSTRAINT - NON-DESTRUCTIVE GUIDE:
    - The colored boxes in the "Layout Guide" are for positioning only. They MUST NOT appear in the final image.

    ${placementInstructions}

    ${refinement ? `USER REFINEMENT INSTRUCTIONS: ${refinement}` : ''}
  `;

  // Build the parts array
  const parts = [
    { text: prompt },
    { inlineData: { mimeType: 'image/png', data: stripBase64Header(cleanBackground) } }, // Input 1
    { inlineData: { mimeType: 'image/png', data: stripBase64Header(layoutGuide) } },     // Input 2
    ...characters.map(c => ({
      inlineData: { mimeType: 'image/png', data: stripBase64Header(c.image) }            // Input 3+
    }))
  ];

  // Parallel requests for quantity
  const promises = Array.from({ length: count }).map(() => 
    ai.models.generateContent({
      model: 'gemini-3-pro-image-preview',
      contents: { parts },
      config: {
        imageConfig: { imageSize: "1K" }
      }
    })
  );

  const responses = await Promise.all(promises);
  const images: string[] = [];

  for (const response of responses) {
    if (response.candidates && response.candidates[0].content.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData && part.inlineData.data) {
          images.push(`data:${part.inlineData.mimeType};base64,${part.inlineData.data}`);
          break;
        }
      }
    }
  }

  if (images.length === 0) {
    throw new Error("No composite images generated.");
  }

  return images;
};

export const upscaleImage = async (imageBase64: string): Promise<string> => {
  const apiKey = getGeminiApiKey();
  const ai = new GoogleGenAI({ apiKey });

  const prompt = `
    Upscale this image to 2K resolution.
    CRITICAL: Do NOT change the composition, content, style, or details. 
    Simply increase the fidelity, sharpness, and resolution.
    The output must be identical to the input, just higher quality.
  `;

  const response = await ai.models.generateContent({
    model: 'gemini-3-pro-image-preview',
    contents: {
      parts: [
        { text: prompt },
        { inlineData: { mimeType: 'image/png', data: stripBase64Header(imageBase64) } }
      ]
    },
    config: {
      imageConfig: { 
        imageSize: "2K",
        // Do not set aspectRatio here, let it infer from source or default, 
        // usually 2K upscale keeps aspect ratio if not forced, but we just want high res.
      }
    }
  });

  let upscaled = "";
  if (response.candidates && response.candidates[0].content.parts) {
    for (const part of response.candidates[0].content.parts) {
      if (part.inlineData && part.inlineData.data) {
        upscaled = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
        break;
      }
    }
  }

  if (!upscaled) {
    throw new Error("Upscaling failed.");
  }

  return upscaled;
};
